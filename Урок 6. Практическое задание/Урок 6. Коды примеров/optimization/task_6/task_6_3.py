"""Профилировка времени и памяти"""
"""
Генераторы это тоже итерируемые объекты, но прочитать их можно лишь один раз.
 Это связано с тем, что они не хранят значения в памяти, а генерируют их на лету.
"""

"""
Всё то же самое, разве что используются круглые скобки вместо квадратных.
НО: нельзя применить конструкцию for i in mygenerator второй раз, 
так как генератор может быть использован только единожды: 
он вычисляет 0, потом забывает про него и вычисляет 1, 
завершаяя вычислением 4 — одно за другим.
"""
# Выполнение заняло 0.0 сек and 0.01171875 Мб

import memory_profiler
import time


def check_even(numbers):
    for num in numbers:
        if num % 2 == 0:
            yield num * num

print(check_even([1, 2, 3, 4, 5]))
mygenerator = check_even([1, 2, 3, 4, 5])
for i in mygenerator:
    print(i)

if __name__ == '__main__':

    t1 = time.process_time()
    m1 = memory_profiler.memory_usage()

    mygenerator = check_even([1, 2, 3, 4, 5])
    for i in mygenerator:
        print(i)

    t2 = time.process_time()
    m2 = memory_profiler.memory_usage()

    time_diff = t2 - t1
    mem_diff = m2[0] - m1[0]
    print(f"Выполнение заняло {time_diff} сек and {mem_diff} Мб")

"""
Генераторы дают возможность производить «ленивые» вычисления. 
Суть использования такого вычисления заключается в итерации: 
как с помощью явного использования “for”, так и неявного. 
For просто передает это вычисление любой функции или конструкции, 
которая и осуществляет итерацию.
Вы можете подумать, что генераторы возвращают любое количество 
элементов наподобие списка, однако вместо того, 
чтобы возвращать их все сразу они возвращаются один за другим. 
Функция генератора останавливается до тех пор, 
пока следующий элемент не будет запрошен.
"""
